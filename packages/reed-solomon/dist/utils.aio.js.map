{"version":3,"file":"utils.aio.js","sources":["../../../node_modules/.pnpm/@ethersproject+logger@5.7.0/node_modules/@ethersproject/logger/lib.esm/index.js","../../../node_modules/.pnpm/@ethersproject+logger@5.7.0/node_modules/@ethersproject/logger/lib.esm/_version.js","../../../node_modules/.pnpm/@ethersproject+bytes@5.7.0/node_modules/@ethersproject/bytes/lib.esm/_version.js","../../../node_modules/.pnpm/@ethersproject+bytes@5.7.0/node_modules/@ethersproject/bytes/lib.esm/index.js","../../../node_modules/.pnpm/@ethersproject+base64@5.7.0/node_modules/@ethersproject/base64/lib.esm/base64.js","../../../node_modules/.pnpm/@noble+hashes@1.4.0/node_modules/@noble/hashes/esm/_assert.js","../../../node_modules/.pnpm/@noble+hashes@1.4.0/node_modules/@noble/hashes/esm/utils.js","../../../node_modules/.pnpm/@noble+hashes@1.4.0/node_modules/@noble/hashes/esm/_md.js","../../../node_modules/.pnpm/@noble+hashes@1.4.0/node_modules/@noble/hashes/esm/sha256.js","../../../node_modules/.pnpm/ethereum-cryptography@2.2.0/node_modules/ethereum-cryptography/esm/utils.js","../../../node_modules/.pnpm/ethereum-cryptography@2.2.0/node_modules/ethereum-cryptography/esm/sha256.js","../src/utils.js"],"sourcesContent":["\"use strict\";\nlet _permanentCensorErrors = false;\nlet _censorErrors = false;\nconst LogLevels = { debug: 1, \"default\": 2, info: 2, warning: 3, error: 4, off: 5 };\nlet _logLevel = LogLevels[\"default\"];\nimport { version } from \"./_version\";\nlet _globalLogger = null;\nfunction _checkNormalize() {\n    try {\n        const missing = [];\n        // Make sure all forms of normalization are supported\n        [\"NFD\", \"NFC\", \"NFKD\", \"NFKC\"].forEach((form) => {\n            try {\n                if (\"test\".normalize(form) !== \"test\") {\n                    throw new Error(\"bad normalize\");\n                }\n                ;\n            }\n            catch (error) {\n                missing.push(form);\n            }\n        });\n        if (missing.length) {\n            throw new Error(\"missing \" + missing.join(\", \"));\n        }\n        if (String.fromCharCode(0xe9).normalize(\"NFD\") !== String.fromCharCode(0x65, 0x0301)) {\n            throw new Error(\"broken implementation\");\n        }\n    }\n    catch (error) {\n        return error.message;\n    }\n    return null;\n}\nconst _normalizeError = _checkNormalize();\nexport var LogLevel;\n(function (LogLevel) {\n    LogLevel[\"DEBUG\"] = \"DEBUG\";\n    LogLevel[\"INFO\"] = \"INFO\";\n    LogLevel[\"WARNING\"] = \"WARNING\";\n    LogLevel[\"ERROR\"] = \"ERROR\";\n    LogLevel[\"OFF\"] = \"OFF\";\n})(LogLevel || (LogLevel = {}));\nexport var ErrorCode;\n(function (ErrorCode) {\n    ///////////////////\n    // Generic Errors\n    // Unknown Error\n    ErrorCode[\"UNKNOWN_ERROR\"] = \"UNKNOWN_ERROR\";\n    // Not Implemented\n    ErrorCode[\"NOT_IMPLEMENTED\"] = \"NOT_IMPLEMENTED\";\n    // Unsupported Operation\n    //   - operation\n    ErrorCode[\"UNSUPPORTED_OPERATION\"] = \"UNSUPPORTED_OPERATION\";\n    // Network Error (i.e. Ethereum Network, such as an invalid chain ID)\n    //   - event (\"noNetwork\" is not re-thrown in provider.ready; otherwise thrown)\n    ErrorCode[\"NETWORK_ERROR\"] = \"NETWORK_ERROR\";\n    // Some sort of bad response from the server\n    ErrorCode[\"SERVER_ERROR\"] = \"SERVER_ERROR\";\n    // Timeout\n    ErrorCode[\"TIMEOUT\"] = \"TIMEOUT\";\n    ///////////////////\n    // Operational  Errors\n    // Buffer Overrun\n    ErrorCode[\"BUFFER_OVERRUN\"] = \"BUFFER_OVERRUN\";\n    // Numeric Fault\n    //   - operation: the operation being executed\n    //   - fault: the reason this faulted\n    ErrorCode[\"NUMERIC_FAULT\"] = \"NUMERIC_FAULT\";\n    ///////////////////\n    // Argument Errors\n    // Missing new operator to an object\n    //  - name: The name of the class\n    ErrorCode[\"MISSING_NEW\"] = \"MISSING_NEW\";\n    // Invalid argument (e.g. value is incompatible with type) to a function:\n    //   - argument: The argument name that was invalid\n    //   - value: The value of the argument\n    ErrorCode[\"INVALID_ARGUMENT\"] = \"INVALID_ARGUMENT\";\n    // Missing argument to a function:\n    //   - count: The number of arguments received\n    //   - expectedCount: The number of arguments expected\n    ErrorCode[\"MISSING_ARGUMENT\"] = \"MISSING_ARGUMENT\";\n    // Too many arguments\n    //   - count: The number of arguments received\n    //   - expectedCount: The number of arguments expected\n    ErrorCode[\"UNEXPECTED_ARGUMENT\"] = \"UNEXPECTED_ARGUMENT\";\n    ///////////////////\n    // Blockchain Errors\n    // Call exception\n    //  - transaction: the transaction\n    //  - address?: the contract address\n    //  - args?: The arguments passed into the function\n    //  - method?: The Solidity method signature\n    //  - errorSignature?: The EIP848 error signature\n    //  - errorArgs?: The EIP848 error parameters\n    //  - reason: The reason (only for EIP848 \"Error(string)\")\n    ErrorCode[\"CALL_EXCEPTION\"] = \"CALL_EXCEPTION\";\n    // Insufficient funds (< value + gasLimit * gasPrice)\n    //   - transaction: the transaction attempted\n    ErrorCode[\"INSUFFICIENT_FUNDS\"] = \"INSUFFICIENT_FUNDS\";\n    // Nonce has already been used\n    //   - transaction: the transaction attempted\n    ErrorCode[\"NONCE_EXPIRED\"] = \"NONCE_EXPIRED\";\n    // The replacement fee for the transaction is too low\n    //   - transaction: the transaction attempted\n    ErrorCode[\"REPLACEMENT_UNDERPRICED\"] = \"REPLACEMENT_UNDERPRICED\";\n    // The gas limit could not be estimated\n    //   - transaction: the transaction passed to estimateGas\n    ErrorCode[\"UNPREDICTABLE_GAS_LIMIT\"] = \"UNPREDICTABLE_GAS_LIMIT\";\n    // The transaction was replaced by one with a higher gas price\n    //   - reason: \"cancelled\", \"replaced\" or \"repriced\"\n    //   - cancelled: true if reason == \"cancelled\" or reason == \"replaced\")\n    //   - hash: original transaction hash\n    //   - replacement: the full TransactionsResponse for the replacement\n    //   - receipt: the receipt of the replacement\n    ErrorCode[\"TRANSACTION_REPLACED\"] = \"TRANSACTION_REPLACED\";\n    ///////////////////\n    // Interaction Errors\n    // The user rejected the action, such as signing a message or sending\n    // a transaction\n    ErrorCode[\"ACTION_REJECTED\"] = \"ACTION_REJECTED\";\n})(ErrorCode || (ErrorCode = {}));\n;\nconst HEX = \"0123456789abcdef\";\nexport class Logger {\n    constructor(version) {\n        Object.defineProperty(this, \"version\", {\n            enumerable: true,\n            value: version,\n            writable: false\n        });\n    }\n    _log(logLevel, args) {\n        const level = logLevel.toLowerCase();\n        if (LogLevels[level] == null) {\n            this.throwArgumentError(\"invalid log level name\", \"logLevel\", logLevel);\n        }\n        if (_logLevel > LogLevels[level]) {\n            return;\n        }\n        console.log.apply(console, args);\n    }\n    debug(...args) {\n        this._log(Logger.levels.DEBUG, args);\n    }\n    info(...args) {\n        this._log(Logger.levels.INFO, args);\n    }\n    warn(...args) {\n        this._log(Logger.levels.WARNING, args);\n    }\n    makeError(message, code, params) {\n        // Errors are being censored\n        if (_censorErrors) {\n            return this.makeError(\"censored error\", code, {});\n        }\n        if (!code) {\n            code = Logger.errors.UNKNOWN_ERROR;\n        }\n        if (!params) {\n            params = {};\n        }\n        const messageDetails = [];\n        Object.keys(params).forEach((key) => {\n            const value = params[key];\n            try {\n                if (value instanceof Uint8Array) {\n                    let hex = \"\";\n                    for (let i = 0; i < value.length; i++) {\n                        hex += HEX[value[i] >> 4];\n                        hex += HEX[value[i] & 0x0f];\n                    }\n                    messageDetails.push(key + \"=Uint8Array(0x\" + hex + \")\");\n                }\n                else {\n                    messageDetails.push(key + \"=\" + JSON.stringify(value));\n                }\n            }\n            catch (error) {\n                messageDetails.push(key + \"=\" + JSON.stringify(params[key].toString()));\n            }\n        });\n        messageDetails.push(`code=${code}`);\n        messageDetails.push(`version=${this.version}`);\n        const reason = message;\n        let url = \"\";\n        switch (code) {\n            case ErrorCode.NUMERIC_FAULT: {\n                url = \"NUMERIC_FAULT\";\n                const fault = message;\n                switch (fault) {\n                    case \"overflow\":\n                    case \"underflow\":\n                    case \"division-by-zero\":\n                        url += \"-\" + fault;\n                        break;\n                    case \"negative-power\":\n                    case \"negative-width\":\n                        url += \"-unsupported\";\n                        break;\n                    case \"unbound-bitwise-result\":\n                        url += \"-unbound-result\";\n                        break;\n                }\n                break;\n            }\n            case ErrorCode.CALL_EXCEPTION:\n            case ErrorCode.INSUFFICIENT_FUNDS:\n            case ErrorCode.MISSING_NEW:\n            case ErrorCode.NONCE_EXPIRED:\n            case ErrorCode.REPLACEMENT_UNDERPRICED:\n            case ErrorCode.TRANSACTION_REPLACED:\n            case ErrorCode.UNPREDICTABLE_GAS_LIMIT:\n                url = code;\n                break;\n        }\n        if (url) {\n            message += \" [ See: https:/\\/links.ethers.org/v5-errors-\" + url + \" ]\";\n        }\n        if (messageDetails.length) {\n            message += \" (\" + messageDetails.join(\", \") + \")\";\n        }\n        // @TODO: Any??\n        const error = new Error(message);\n        error.reason = reason;\n        error.code = code;\n        Object.keys(params).forEach(function (key) {\n            error[key] = params[key];\n        });\n        return error;\n    }\n    throwError(message, code, params) {\n        throw this.makeError(message, code, params);\n    }\n    throwArgumentError(message, name, value) {\n        return this.throwError(message, Logger.errors.INVALID_ARGUMENT, {\n            argument: name,\n            value: value\n        });\n    }\n    assert(condition, message, code, params) {\n        if (!!condition) {\n            return;\n        }\n        this.throwError(message, code, params);\n    }\n    assertArgument(condition, message, name, value) {\n        if (!!condition) {\n            return;\n        }\n        this.throwArgumentError(message, name, value);\n    }\n    checkNormalize(message) {\n        if (message == null) {\n            message = \"platform missing String.prototype.normalize\";\n        }\n        if (_normalizeError) {\n            this.throwError(\"platform missing String.prototype.normalize\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"String.prototype.normalize\", form: _normalizeError\n            });\n        }\n    }\n    checkSafeUint53(value, message) {\n        if (typeof (value) !== \"number\") {\n            return;\n        }\n        if (message == null) {\n            message = \"value not safe\";\n        }\n        if (value < 0 || value >= 0x1fffffffffffff) {\n            this.throwError(message, Logger.errors.NUMERIC_FAULT, {\n                operation: \"checkSafeInteger\",\n                fault: \"out-of-safe-range\",\n                value: value\n            });\n        }\n        if (value % 1) {\n            this.throwError(message, Logger.errors.NUMERIC_FAULT, {\n                operation: \"checkSafeInteger\",\n                fault: \"non-integer\",\n                value: value\n            });\n        }\n    }\n    checkArgumentCount(count, expectedCount, message) {\n        if (message) {\n            message = \": \" + message;\n        }\n        else {\n            message = \"\";\n        }\n        if (count < expectedCount) {\n            this.throwError(\"missing argument\" + message, Logger.errors.MISSING_ARGUMENT, {\n                count: count,\n                expectedCount: expectedCount\n            });\n        }\n        if (count > expectedCount) {\n            this.throwError(\"too many arguments\" + message, Logger.errors.UNEXPECTED_ARGUMENT, {\n                count: count,\n                expectedCount: expectedCount\n            });\n        }\n    }\n    checkNew(target, kind) {\n        if (target === Object || target == null) {\n            this.throwError(\"missing new\", Logger.errors.MISSING_NEW, { name: kind.name });\n        }\n    }\n    checkAbstract(target, kind) {\n        if (target === kind) {\n            this.throwError(\"cannot instantiate abstract class \" + JSON.stringify(kind.name) + \" directly; use a sub-class\", Logger.errors.UNSUPPORTED_OPERATION, { name: target.name, operation: \"new\" });\n        }\n        else if (target === Object || target == null) {\n            this.throwError(\"missing new\", Logger.errors.MISSING_NEW, { name: kind.name });\n        }\n    }\n    static globalLogger() {\n        if (!_globalLogger) {\n            _globalLogger = new Logger(version);\n        }\n        return _globalLogger;\n    }\n    static setCensorship(censorship, permanent) {\n        if (!censorship && permanent) {\n            this.globalLogger().throwError(\"cannot permanently disable censorship\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"setCensorship\"\n            });\n        }\n        if (_permanentCensorErrors) {\n            if (!censorship) {\n                return;\n            }\n            this.globalLogger().throwError(\"error censorship permanent\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"setCensorship\"\n            });\n        }\n        _censorErrors = !!censorship;\n        _permanentCensorErrors = !!permanent;\n    }\n    static setLogLevel(logLevel) {\n        const level = LogLevels[logLevel.toLowerCase()];\n        if (level == null) {\n            Logger.globalLogger().warn(\"invalid log level - \" + logLevel);\n            return;\n        }\n        _logLevel = level;\n    }\n    static from(version) {\n        return new Logger(version);\n    }\n}\nLogger.errors = ErrorCode;\nLogger.levels = LogLevel;\n//# sourceMappingURL=index.js.map","export const version = \"logger/5.7.0\";\n//# sourceMappingURL=_version.js.map","export const version = \"bytes/5.7.0\";\n//# sourceMappingURL=_version.js.map","\"use strict\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n///////////////////////////////\nfunction isHexable(value) {\n    return !!(value.toHexString);\n}\nfunction addSlice(array) {\n    if (array.slice) {\n        return array;\n    }\n    array.slice = function () {\n        const args = Array.prototype.slice.call(arguments);\n        return addSlice(new Uint8Array(Array.prototype.slice.apply(array, args)));\n    };\n    return array;\n}\nexport function isBytesLike(value) {\n    return ((isHexString(value) && !(value.length % 2)) || isBytes(value));\n}\nfunction isInteger(value) {\n    return (typeof (value) === \"number\" && value == value && (value % 1) === 0);\n}\nexport function isBytes(value) {\n    if (value == null) {\n        return false;\n    }\n    if (value.constructor === Uint8Array) {\n        return true;\n    }\n    if (typeof (value) === \"string\") {\n        return false;\n    }\n    if (!isInteger(value.length) || value.length < 0) {\n        return false;\n    }\n    for (let i = 0; i < value.length; i++) {\n        const v = value[i];\n        if (!isInteger(v) || v < 0 || v >= 256) {\n            return false;\n        }\n    }\n    return true;\n}\nexport function arrayify(value, options) {\n    if (!options) {\n        options = {};\n    }\n    if (typeof (value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid arrayify value\");\n        const result = [];\n        while (value) {\n            result.unshift(value & 0xff);\n            value = parseInt(String(value / 256));\n        }\n        if (result.length === 0) {\n            result.push(0);\n        }\n        return addSlice(new Uint8Array(result));\n    }\n    if (options.allowMissingPrefix && typeof (value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n        value = \"0x\" + value;\n    }\n    if (isHexable(value)) {\n        value = value.toHexString();\n    }\n    if (isHexString(value)) {\n        let hex = value.substring(2);\n        if (hex.length % 2) {\n            if (options.hexPad === \"left\") {\n                hex = \"0\" + hex;\n            }\n            else if (options.hexPad === \"right\") {\n                hex += \"0\";\n            }\n            else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n        const result = [];\n        for (let i = 0; i < hex.length; i += 2) {\n            result.push(parseInt(hex.substring(i, i + 2), 16));\n        }\n        return addSlice(new Uint8Array(result));\n    }\n    if (isBytes(value)) {\n        return addSlice(new Uint8Array(value));\n    }\n    return logger.throwArgumentError(\"invalid arrayify value\", \"value\", value);\n}\nexport function concat(items) {\n    const objects = items.map(item => arrayify(item));\n    const length = objects.reduce((accum, item) => (accum + item.length), 0);\n    const result = new Uint8Array(length);\n    objects.reduce((offset, object) => {\n        result.set(object, offset);\n        return offset + object.length;\n    }, 0);\n    return addSlice(result);\n}\nexport function stripZeros(value) {\n    let result = arrayify(value);\n    if (result.length === 0) {\n        return result;\n    }\n    // Find the first non-zero entry\n    let start = 0;\n    while (start < result.length && result[start] === 0) {\n        start++;\n    }\n    // If we started with zeros, strip them\n    if (start) {\n        result = result.slice(start);\n    }\n    return result;\n}\nexport function zeroPad(value, length) {\n    value = arrayify(value);\n    if (value.length > length) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[0]);\n    }\n    const result = new Uint8Array(length);\n    result.set(value, length - value.length);\n    return addSlice(result);\n}\nexport function isHexString(value, length) {\n    if (typeof (value) !== \"string\" || !value.match(/^0x[0-9A-Fa-f]*$/)) {\n        return false;\n    }\n    if (length && value.length !== 2 + 2 * length) {\n        return false;\n    }\n    return true;\n}\nconst HexCharacters = \"0123456789abcdef\";\nexport function hexlify(value, options) {\n    if (!options) {\n        options = {};\n    }\n    if (typeof (value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid hexlify value\");\n        let hex = \"\";\n        while (value) {\n            hex = HexCharacters[value & 0xf] + hex;\n            value = Math.floor(value / 16);\n        }\n        if (hex.length) {\n            if (hex.length % 2) {\n                hex = \"0\" + hex;\n            }\n            return \"0x\" + hex;\n        }\n        return \"0x00\";\n    }\n    if (typeof (value) === \"bigint\") {\n        value = value.toString(16);\n        if (value.length % 2) {\n            return (\"0x0\" + value);\n        }\n        return \"0x\" + value;\n    }\n    if (options.allowMissingPrefix && typeof (value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n        value = \"0x\" + value;\n    }\n    if (isHexable(value)) {\n        return value.toHexString();\n    }\n    if (isHexString(value)) {\n        if (value.length % 2) {\n            if (options.hexPad === \"left\") {\n                value = \"0x0\" + value.substring(2);\n            }\n            else if (options.hexPad === \"right\") {\n                value += \"0\";\n            }\n            else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n        return value.toLowerCase();\n    }\n    if (isBytes(value)) {\n        let result = \"0x\";\n        for (let i = 0; i < value.length; i++) {\n            let v = value[i];\n            result += HexCharacters[(v & 0xf0) >> 4] + HexCharacters[v & 0x0f];\n        }\n        return result;\n    }\n    return logger.throwArgumentError(\"invalid hexlify value\", \"value\", value);\n}\n/*\nfunction unoddify(value: BytesLike | Hexable | number): BytesLike | Hexable | number {\n    if (typeof(value) === \"string\" && value.length % 2 && value.substring(0, 2) === \"0x\") {\n        return \"0x0\" + value.substring(2);\n    }\n    return value;\n}\n*/\nexport function hexDataLength(data) {\n    if (typeof (data) !== \"string\") {\n        data = hexlify(data);\n    }\n    else if (!isHexString(data) || (data.length % 2)) {\n        return null;\n    }\n    return (data.length - 2) / 2;\n}\nexport function hexDataSlice(data, offset, endOffset) {\n    if (typeof (data) !== \"string\") {\n        data = hexlify(data);\n    }\n    else if (!isHexString(data) || (data.length % 2)) {\n        logger.throwArgumentError(\"invalid hexData\", \"value\", data);\n    }\n    offset = 2 + 2 * offset;\n    if (endOffset != null) {\n        return \"0x\" + data.substring(offset, 2 + 2 * endOffset);\n    }\n    return \"0x\" + data.substring(offset);\n}\nexport function hexConcat(items) {\n    let result = \"0x\";\n    items.forEach((item) => {\n        result += hexlify(item).substring(2);\n    });\n    return result;\n}\nexport function hexValue(value) {\n    const trimmed = hexStripZeros(hexlify(value, { hexPad: \"left\" }));\n    if (trimmed === \"0x\") {\n        return \"0x0\";\n    }\n    return trimmed;\n}\nexport function hexStripZeros(value) {\n    if (typeof (value) !== \"string\") {\n        value = hexlify(value);\n    }\n    if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n    value = value.substring(2);\n    let offset = 0;\n    while (offset < value.length && value[offset] === \"0\") {\n        offset++;\n    }\n    return \"0x\" + value.substring(offset);\n}\nexport function hexZeroPad(value, length) {\n    if (typeof (value) !== \"string\") {\n        value = hexlify(value);\n    }\n    else if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n    if (value.length > 2 * length + 2) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[1]);\n    }\n    while (value.length < 2 * length + 2) {\n        value = \"0x0\" + value.substring(2);\n    }\n    return value;\n}\nexport function splitSignature(signature) {\n    const result = {\n        r: \"0x\",\n        s: \"0x\",\n        _vs: \"0x\",\n        recoveryParam: 0,\n        v: 0,\n        yParityAndS: \"0x\",\n        compact: \"0x\"\n    };\n    if (isBytesLike(signature)) {\n        let bytes = arrayify(signature);\n        // Get the r, s and v\n        if (bytes.length === 64) {\n            // EIP-2098; pull the v from the top bit of s and clear it\n            result.v = 27 + (bytes[32] >> 7);\n            bytes[32] &= 0x7f;\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n        }\n        else if (bytes.length === 65) {\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n            result.v = bytes[64];\n        }\n        else {\n            logger.throwArgumentError(\"invalid signature string\", \"signature\", signature);\n        }\n        // Allow a recid to be used as the v\n        if (result.v < 27) {\n            if (result.v === 0 || result.v === 1) {\n                result.v += 27;\n            }\n            else {\n                logger.throwArgumentError(\"signature invalid v byte\", \"signature\", signature);\n            }\n        }\n        // Compute recoveryParam from v\n        result.recoveryParam = 1 - (result.v % 2);\n        // Compute _vs from recoveryParam and s\n        if (result.recoveryParam) {\n            bytes[32] |= 0x80;\n        }\n        result._vs = hexlify(bytes.slice(32, 64));\n    }\n    else {\n        result.r = signature.r;\n        result.s = signature.s;\n        result.v = signature.v;\n        result.recoveryParam = signature.recoveryParam;\n        result._vs = signature._vs;\n        // If the _vs is available, use it to populate missing s, v and recoveryParam\n        // and verify non-missing s, v and recoveryParam\n        if (result._vs != null) {\n            const vs = zeroPad(arrayify(result._vs), 32);\n            result._vs = hexlify(vs);\n            // Set or check the recid\n            const recoveryParam = ((vs[0] >= 128) ? 1 : 0);\n            if (result.recoveryParam == null) {\n                result.recoveryParam = recoveryParam;\n            }\n            else if (result.recoveryParam !== recoveryParam) {\n                logger.throwArgumentError(\"signature recoveryParam mismatch _vs\", \"signature\", signature);\n            }\n            // Set or check the s\n            vs[0] &= 0x7f;\n            const s = hexlify(vs);\n            if (result.s == null) {\n                result.s = s;\n            }\n            else if (result.s !== s) {\n                logger.throwArgumentError(\"signature v mismatch _vs\", \"signature\", signature);\n            }\n        }\n        // Use recid and v to populate each other\n        if (result.recoveryParam == null) {\n            if (result.v == null) {\n                logger.throwArgumentError(\"signature missing v and recoveryParam\", \"signature\", signature);\n            }\n            else if (result.v === 0 || result.v === 1) {\n                result.recoveryParam = result.v;\n            }\n            else {\n                result.recoveryParam = 1 - (result.v % 2);\n            }\n        }\n        else {\n            if (result.v == null) {\n                result.v = 27 + result.recoveryParam;\n            }\n            else {\n                const recId = (result.v === 0 || result.v === 1) ? result.v : (1 - (result.v % 2));\n                if (result.recoveryParam !== recId) {\n                    logger.throwArgumentError(\"signature recoveryParam mismatch v\", \"signature\", signature);\n                }\n            }\n        }\n        if (result.r == null || !isHexString(result.r)) {\n            logger.throwArgumentError(\"signature missing or invalid r\", \"signature\", signature);\n        }\n        else {\n            result.r = hexZeroPad(result.r, 32);\n        }\n        if (result.s == null || !isHexString(result.s)) {\n            logger.throwArgumentError(\"signature missing or invalid s\", \"signature\", signature);\n        }\n        else {\n            result.s = hexZeroPad(result.s, 32);\n        }\n        const vs = arrayify(result.s);\n        if (vs[0] >= 128) {\n            logger.throwArgumentError(\"signature s out of range\", \"signature\", signature);\n        }\n        if (result.recoveryParam) {\n            vs[0] |= 0x80;\n        }\n        const _vs = hexlify(vs);\n        if (result._vs) {\n            if (!isHexString(result._vs)) {\n                logger.throwArgumentError(\"signature invalid _vs\", \"signature\", signature);\n            }\n            result._vs = hexZeroPad(result._vs, 32);\n        }\n        // Set or check the _vs\n        if (result._vs == null) {\n            result._vs = _vs;\n        }\n        else if (result._vs !== _vs) {\n            logger.throwArgumentError(\"signature _vs mismatch v and s\", \"signature\", signature);\n        }\n    }\n    result.yParityAndS = result._vs;\n    result.compact = result.r + result.yParityAndS.substring(2);\n    return result;\n}\nexport function joinSignature(signature) {\n    signature = splitSignature(signature);\n    return hexlify(concat([\n        signature.r,\n        signature.s,\n        (signature.recoveryParam ? \"0x1c\" : \"0x1b\")\n    ]));\n}\n//# sourceMappingURL=index.js.map","\"use strict\";\nimport { arrayify } from \"@ethersproject/bytes\";\nexport function decode(textData) {\n    textData = atob(textData);\n    const data = [];\n    for (let i = 0; i < textData.length; i++) {\n        data.push(textData.charCodeAt(i));\n    }\n    return arrayify(data);\n}\nexport function encode(data) {\n    data = arrayify(data);\n    let textData = \"\";\n    for (let i = 0; i < data.length; i++) {\n        textData += String.fromCharCode(data[i]);\n    }\n    return btoa(textData);\n}\n//# sourceMappingURL=base64.js.map","function number(n) {\n    if (!Number.isSafeInteger(n) || n < 0)\n        throw new Error(`positive integer expected, not ${n}`);\n}\nfunction bool(b) {\n    if (typeof b !== 'boolean')\n        throw new Error(`boolean expected, not ${b}`);\n}\n// copied from utils\nexport function isBytes(a) {\n    return (a instanceof Uint8Array ||\n        (a != null && typeof a === 'object' && a.constructor.name === 'Uint8Array'));\n}\nfunction bytes(b, ...lengths) {\n    if (!isBytes(b))\n        throw new Error('Uint8Array expected');\n    if (lengths.length > 0 && !lengths.includes(b.length))\n        throw new Error(`Uint8Array expected of length ${lengths}, not of length=${b.length}`);\n}\nfunction hash(h) {\n    if (typeof h !== 'function' || typeof h.create !== 'function')\n        throw new Error('Hash should be wrapped by utils.wrapConstructor');\n    number(h.outputLen);\n    number(h.blockLen);\n}\nfunction exists(instance, checkFinished = true) {\n    if (instance.destroyed)\n        throw new Error('Hash instance has been destroyed');\n    if (checkFinished && instance.finished)\n        throw new Error('Hash#digest() has already been called');\n}\nfunction output(out, instance) {\n    bytes(out);\n    const min = instance.outputLen;\n    if (out.length < min) {\n        throw new Error(`digestInto() expects output buffer of length at least ${min}`);\n    }\n}\nexport { number, bool, bytes, hash, exists, output };\nconst assert = { number, bool, bytes, hash, exists, output };\nexport default assert;\n//# sourceMappingURL=_assert.js.map","/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// node.js versions earlier than v19 don't declare it in global scope.\n// For node.js, package.json#exports field mapping rewrites import\n// from `crypto` to `cryptoNode`, which imports native module.\n// Makes the utils un-importable in browsers without a bundler.\n// Once node.js 18 is deprecated (2025-04-30), we can just drop the import.\nimport { crypto } from '@noble/hashes/crypto';\nimport { bytes as abytes } from './_assert.js';\n// export { isBytes } from './_assert.js';\n// We can't reuse isBytes from _assert, because somehow this causes huge perf issues\nexport function isBytes(a) {\n    return (a instanceof Uint8Array ||\n        (a != null && typeof a === 'object' && a.constructor.name === 'Uint8Array'));\n}\n// Cast array to different type\nexport const u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\nexport const u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n// Cast array to view\nexport const createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n// The rotate right (circular right shift) operation for uint32\nexport const rotr = (word, shift) => (word << (32 - shift)) | (word >>> shift);\n// The rotate left (circular left shift) operation for uint32\nexport const rotl = (word, shift) => (word << shift) | ((word >>> (32 - shift)) >>> 0);\nexport const isLE = new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44;\n// The byte swap operation for uint32\nexport const byteSwap = (word) => ((word << 24) & 0xff000000) |\n    ((word << 8) & 0xff0000) |\n    ((word >>> 8) & 0xff00) |\n    ((word >>> 24) & 0xff);\n// Conditionally byte swap if on a big-endian platform\nexport const byteSwapIfBE = isLE ? (n) => n : (n) => byteSwap(n);\n// In place byte swap for Uint32Array\nexport function byteSwap32(arr) {\n    for (let i = 0; i < arr.length; i++) {\n        arr[i] = byteSwap(arr[i]);\n    }\n}\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nexport function bytesToHex(bytes) {\n    abytes(bytes);\n    // pre-caching improves the speed 6x\n    let hex = '';\n    for (let i = 0; i < bytes.length; i++) {\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\n// We use optimized technique to convert hex string to byte array\nconst asciis = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };\nfunction asciiToBase16(char) {\n    if (char >= asciis._0 && char <= asciis._9)\n        return char - asciis._0;\n    if (char >= asciis._A && char <= asciis._F)\n        return char - (asciis._A - 10);\n    if (char >= asciis._a && char <= asciis._f)\n        return char - (asciis._a - 10);\n    return;\n}\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nexport function hexToBytes(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    const hl = hex.length;\n    const al = hl / 2;\n    if (hl % 2)\n        throw new Error('padded hex string expected, got unpadded hex of length ' + hl);\n    const array = new Uint8Array(al);\n    for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n        const n1 = asciiToBase16(hex.charCodeAt(hi));\n        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n        if (n1 === undefined || n2 === undefined) {\n            const char = hex[hi] + hex[hi + 1];\n            throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n        }\n        array[ai] = n1 * 16 + n2;\n    }\n    return array;\n}\n// There is no setImmediate in browser and setTimeout is slow.\n// call of async fn will return Promise, which will be fullfiled only on\n// next scheduler queue processing step and this is exactly what we need.\nexport const nextTick = async () => { };\n// Returns control to thread each 'tick' ms to avoid blocking\nexport async function asyncLoop(iters, tick, cb) {\n    let ts = Date.now();\n    for (let i = 0; i < iters; i++) {\n        cb(i);\n        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n        const diff = Date.now() - ts;\n        if (diff >= 0 && diff < tick)\n            continue;\n        await nextTick();\n        ts += diff;\n    }\n}\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nexport function utf8ToBytes(str) {\n    if (typeof str !== 'string')\n        throw new Error(`utf8ToBytes expected string, got ${typeof str}`);\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */\nexport function toBytes(data) {\n    if (typeof data === 'string')\n        data = utf8ToBytes(data);\n    abytes(data);\n    return data;\n}\n/**\n * Copies several Uint8Arrays into one.\n */\nexport function concatBytes(...arrays) {\n    let sum = 0;\n    for (let i = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        abytes(a);\n        sum += a.length;\n    }\n    const res = new Uint8Array(sum);\n    for (let i = 0, pad = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        res.set(a, pad);\n        pad += a.length;\n    }\n    return res;\n}\n// For runtime check if class implements interface\nexport class Hash {\n    // Safe version that clones internal state\n    clone() {\n        return this._cloneInto();\n    }\n}\nconst toStr = {}.toString;\nexport function checkOpts(defaults, opts) {\n    if (opts !== undefined && toStr.call(opts) !== '[object Object]')\n        throw new Error('Options should be object or undefined');\n    const merged = Object.assign(defaults, opts);\n    return merged;\n}\nexport function wrapConstructor(hashCons) {\n    const hashC = (msg) => hashCons().update(toBytes(msg)).digest();\n    const tmp = hashCons();\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = () => hashCons();\n    return hashC;\n}\nexport function wrapConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\nexport function wrapXOFConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\n/**\n * Secure PRNG. Uses `crypto.getRandomValues`, which defers to OS.\n */\nexport function randomBytes(bytesLength = 32) {\n    if (crypto && typeof crypto.getRandomValues === 'function') {\n        return crypto.getRandomValues(new Uint8Array(bytesLength));\n    }\n    throw new Error('crypto.getRandomValues must be defined');\n}\n//# sourceMappingURL=utils.js.map","import { exists, output } from './_assert.js';\nimport { Hash, createView, toBytes } from './utils.js';\n// Polyfill for Safari 14\nfunction setBigUint64(view, byteOffset, value, isLE) {\n    if (typeof view.setBigUint64 === 'function')\n        return view.setBigUint64(byteOffset, value, isLE);\n    const _32n = BigInt(32);\n    const _u32_max = BigInt(0xffffffff);\n    const wh = Number((value >> _32n) & _u32_max);\n    const wl = Number(value & _u32_max);\n    const h = isLE ? 4 : 0;\n    const l = isLE ? 0 : 4;\n    view.setUint32(byteOffset + h, wh, isLE);\n    view.setUint32(byteOffset + l, wl, isLE);\n}\n// Choice: a ? b : c\nexport const Chi = (a, b, c) => (a & b) ^ (~a & c);\n// Majority function, true if any two inpust is true\nexport const Maj = (a, b, c) => (a & b) ^ (a & c) ^ (b & c);\n/**\n * Merkle-Damgard hash construction base class.\n * Could be used to create MD5, RIPEMD, SHA1, SHA2.\n */\nexport class HashMD extends Hash {\n    constructor(blockLen, outputLen, padOffset, isLE) {\n        super();\n        this.blockLen = blockLen;\n        this.outputLen = outputLen;\n        this.padOffset = padOffset;\n        this.isLE = isLE;\n        this.finished = false;\n        this.length = 0;\n        this.pos = 0;\n        this.destroyed = false;\n        this.buffer = new Uint8Array(blockLen);\n        this.view = createView(this.buffer);\n    }\n    update(data) {\n        exists(this);\n        const { view, buffer, blockLen } = this;\n        data = toBytes(data);\n        const len = data.length;\n        for (let pos = 0; pos < len;) {\n            const take = Math.min(blockLen - this.pos, len - pos);\n            // Fast path: we have at least one block in input, cast it to view and process\n            if (take === blockLen) {\n                const dataView = createView(data);\n                for (; blockLen <= len - pos; pos += blockLen)\n                    this.process(dataView, pos);\n                continue;\n            }\n            buffer.set(data.subarray(pos, pos + take), this.pos);\n            this.pos += take;\n            pos += take;\n            if (this.pos === blockLen) {\n                this.process(view, 0);\n                this.pos = 0;\n            }\n        }\n        this.length += data.length;\n        this.roundClean();\n        return this;\n    }\n    digestInto(out) {\n        exists(this);\n        output(out, this);\n        this.finished = true;\n        // Padding\n        // We can avoid allocation of buffer for padding completely if it\n        // was previously not allocated here. But it won't change performance.\n        const { buffer, view, blockLen, isLE } = this;\n        let { pos } = this;\n        // append the bit '1' to the message\n        buffer[pos++] = 0b10000000;\n        this.buffer.subarray(pos).fill(0);\n        // we have less than padOffset left in buffer, so we cannot put length in\n        // current block, need process it and pad again\n        if (this.padOffset > blockLen - pos) {\n            this.process(view, 0);\n            pos = 0;\n        }\n        // Pad until full block byte with zeros\n        for (let i = pos; i < blockLen; i++)\n            buffer[i] = 0;\n        // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that\n        // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.\n        // So we just write lowest 64 bits of that value.\n        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);\n        this.process(view, 0);\n        const oview = createView(out);\n        const len = this.outputLen;\n        // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT\n        if (len % 4)\n            throw new Error('_sha2: outputLen should be aligned to 32bit');\n        const outLen = len / 4;\n        const state = this.get();\n        if (outLen > state.length)\n            throw new Error('_sha2: outputLen bigger than state');\n        for (let i = 0; i < outLen; i++)\n            oview.setUint32(4 * i, state[i], isLE);\n    }\n    digest() {\n        const { buffer, outputLen } = this;\n        this.digestInto(buffer);\n        const res = buffer.slice(0, outputLen);\n        this.destroy();\n        return res;\n    }\n    _cloneInto(to) {\n        to || (to = new this.constructor());\n        to.set(...this.get());\n        const { blockLen, buffer, length, finished, destroyed, pos } = this;\n        to.length = length;\n        to.pos = pos;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        if (length % blockLen)\n            to.buffer.set(buffer);\n        return to;\n    }\n}\n//# sourceMappingURL=_md.js.map","import { HashMD, Chi, Maj } from './_md.js';\nimport { rotr, wrapConstructor } from './utils.js';\n// SHA2-256 need to try 2^128 hashes to execute birthday attack.\n// BTC network is doing 2^67 hashes/sec as per early 2023.\n// Round constants:\n// first 32 bits of the fractional parts of the cube roots of the first 64 primes 2..311)\n// prettier-ignore\nconst SHA256_K = /* @__PURE__ */ new Uint32Array([\n    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n]);\n// Initial state:\n// first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19\n// prettier-ignore\nconst SHA256_IV = /* @__PURE__ */ new Uint32Array([\n    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19\n]);\n// Temporary buffer, not used to store anything between runs\n// Named this way because it matches specification.\nconst SHA256_W = /* @__PURE__ */ new Uint32Array(64);\nclass SHA256 extends HashMD {\n    constructor() {\n        super(64, 32, 8, false);\n        // We cannot use array here since array allows indexing by variable\n        // which means optimizer/compiler cannot use registers.\n        this.A = SHA256_IV[0] | 0;\n        this.B = SHA256_IV[1] | 0;\n        this.C = SHA256_IV[2] | 0;\n        this.D = SHA256_IV[3] | 0;\n        this.E = SHA256_IV[4] | 0;\n        this.F = SHA256_IV[5] | 0;\n        this.G = SHA256_IV[6] | 0;\n        this.H = SHA256_IV[7] | 0;\n    }\n    get() {\n        const { A, B, C, D, E, F, G, H } = this;\n        return [A, B, C, D, E, F, G, H];\n    }\n    // prettier-ignore\n    set(A, B, C, D, E, F, G, H) {\n        this.A = A | 0;\n        this.B = B | 0;\n        this.C = C | 0;\n        this.D = D | 0;\n        this.E = E | 0;\n        this.F = F | 0;\n        this.G = G | 0;\n        this.H = H | 0;\n    }\n    process(view, offset) {\n        // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array\n        for (let i = 0; i < 16; i++, offset += 4)\n            SHA256_W[i] = view.getUint32(offset, false);\n        for (let i = 16; i < 64; i++) {\n            const W15 = SHA256_W[i - 15];\n            const W2 = SHA256_W[i - 2];\n            const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ (W15 >>> 3);\n            const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ (W2 >>> 10);\n            SHA256_W[i] = (s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16]) | 0;\n        }\n        // Compression function main loop, 64 rounds\n        let { A, B, C, D, E, F, G, H } = this;\n        for (let i = 0; i < 64; i++) {\n            const sigma1 = rotr(E, 6) ^ rotr(E, 11) ^ rotr(E, 25);\n            const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n            const sigma0 = rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22);\n            const T2 = (sigma0 + Maj(A, B, C)) | 0;\n            H = G;\n            G = F;\n            F = E;\n            E = (D + T1) | 0;\n            D = C;\n            C = B;\n            B = A;\n            A = (T1 + T2) | 0;\n        }\n        // Add the compressed chunk to the current hash value\n        A = (A + this.A) | 0;\n        B = (B + this.B) | 0;\n        C = (C + this.C) | 0;\n        D = (D + this.D) | 0;\n        E = (E + this.E) | 0;\n        F = (F + this.F) | 0;\n        G = (G + this.G) | 0;\n        H = (H + this.H) | 0;\n        this.set(A, B, C, D, E, F, G, H);\n    }\n    roundClean() {\n        SHA256_W.fill(0);\n    }\n    destroy() {\n        this.set(0, 0, 0, 0, 0, 0, 0, 0);\n        this.buffer.fill(0);\n    }\n}\n// Constants from https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf\nclass SHA224 extends SHA256 {\n    constructor() {\n        super();\n        this.A = 0xc1059ed8 | 0;\n        this.B = 0x367cd507 | 0;\n        this.C = 0x3070dd17 | 0;\n        this.D = 0xf70e5939 | 0;\n        this.E = 0xffc00b31 | 0;\n        this.F = 0x68581511 | 0;\n        this.G = 0x64f98fa7 | 0;\n        this.H = 0xbefa4fa4 | 0;\n        this.outputLen = 28;\n    }\n}\n/**\n * SHA2-256 hash function\n * @param message - data that would be hashed\n */\nexport const sha256 = /* @__PURE__ */ wrapConstructor(() => new SHA256());\nexport const sha224 = /* @__PURE__ */ wrapConstructor(() => new SHA224());\n//# sourceMappingURL=sha256.js.map","import assert from \"@noble/hashes/_assert\";\nimport { hexToBytes as _hexToBytes } from \"@noble/hashes/utils\";\nconst assertBool = assert.bool;\nconst assertBytes = assert.bytes;\nexport { assertBool, assertBytes };\nexport { bytesToHex, bytesToHex as toHex, concatBytes, createView, utf8ToBytes } from \"@noble/hashes/utils\";\n// buf.toString('utf8') -> bytesToUtf8(buf)\nexport function bytesToUtf8(data) {\n    if (!(data instanceof Uint8Array)) {\n        throw new TypeError(`bytesToUtf8 expected Uint8Array, got ${typeof data}`);\n    }\n    return new TextDecoder().decode(data);\n}\nexport function hexToBytes(data) {\n    const sliced = data.startsWith(\"0x\") ? data.substring(2) : data;\n    return _hexToBytes(sliced);\n}\n// buf.equals(buf2) -> equalsBytes(buf, buf2)\nexport function equalsBytes(a, b) {\n    if (a.length !== b.length) {\n        return false;\n    }\n    for (let i = 0; i < a.length; i++) {\n        if (a[i] !== b[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n// Internal utils\nexport function wrapHash(hash) {\n    return (msg) => {\n        assert.bytes(msg);\n        return hash(msg);\n    };\n}\n// TODO(v3): switch away from node crypto, remove this unnecessary variable.\nexport const crypto = (() => {\n    const webCrypto = typeof globalThis === \"object\" && \"crypto\" in globalThis ? globalThis.crypto : undefined;\n    const nodeRequire = typeof module !== \"undefined\" &&\n        typeof module.require === \"function\" &&\n        module.require.bind(module);\n    return {\n        node: nodeRequire && !webCrypto ? nodeRequire(\"crypto\") : undefined,\n        web: webCrypto\n    };\n})();\n","import { sha256 as _sha256 } from \"@noble/hashes/sha256\";\nimport { wrapHash } from \"./utils.js\";\nexport const sha256 = wrapHash(_sha256);\n","import { encode } from '@ethersproject/base64';\nexport { sha256 } from 'ethereum-cryptography/sha256.js';\n\nexport function concat(a, b) {\n  let res = [];\n  a.forEach((i) => {\n    res.push(i);\n  });\n  b.forEach((i) => {\n    res.push(i);\n  });\n  return res;\n}\n\nexport function getIntegrityUint8Array(uint8arr) {\n  const arr = uint8arr.reduce((a, b) => {\n    return concat(a, b);\n  });\n\n  return Uint8Array.from(arr);\n}\n\nexport function toBase64(hashList) {\n  const res = [];\n  for (let i = 0; i < hashList.length; i++) {\n    res.push(encode(hashList[i]));\n  }\n  return res;\n}\n\n/**\n * split data to same length price\n */\nexport function splitPrice(data, size) {\n  let chunkList = [];\n  let cur = 0;\n\n  while (cur < data.length) {\n    chunkList.push(data.slice(cur, cur + size));\n    cur += size;\n  }\n\n  return chunkList;\n}\n"],"names":["_permanentCensorErrors","_censorErrors","LogLevels","debug","default","info","warning","error","off","_logLevel","_globalLogger","_normalizeError","missing","forEach","form","normalize","Error","push","length","join","String","fromCharCode","message","_checkNormalize","LogLevel","ErrorCode","HEX","Logger","constructor","version","Object","defineProperty","this","enumerable","value","writable","_log","logLevel","args","level","toLowerCase","throwArgumentError","console","log","apply","levels","DEBUG","INFO","warn","WARNING","makeError","code","params","errors","UNKNOWN_ERROR","messageDetails","keys","key","Uint8Array","hex","i","JSON","stringify","toString","reason","url","NUMERIC_FAULT","fault","CALL_EXCEPTION","INSUFFICIENT_FUNDS","MISSING_NEW","NONCE_EXPIRED","REPLACEMENT_UNDERPRICED","TRANSACTION_REPLACED","UNPREDICTABLE_GAS_LIMIT","throwError","name","INVALID_ARGUMENT","argument","assert","condition","assertArgument","checkNormalize","UNSUPPORTED_OPERATION","operation","checkSafeUint53","checkArgumentCount","count","expectedCount","MISSING_ARGUMENT","UNEXPECTED_ARGUMENT","checkNew","target","kind","checkAbstract","globalLogger","setCensorship","censorship","permanent","setLogLevel","from","logger","addSlice","array","slice","Array","prototype","call","arguments","isInteger","arrayify","options","result","unshift","parseInt","allowMissingPrefix","substring","isHexable","toHexString","match","isHexString","hexPad","v","isBytes","encode","data","textData","btoa","number","n","Number","isSafeInteger","bytes","b","lengths","a","includes","exists","instance","checkFinished","destroyed","finished","output","out","min","outputLen","bool","hash","h","create","blockLen","createView","arr","DataView","buffer","byteOffset","byteLength","rotr","word","shift","toBytes","str","TextEncoder","utf8ToBytes","abytes","Uint32Array","Hash","clone","_cloneInto","wrapConstructor","hashCons","hashC","msg","update","digest","tmp","Maj","c","HashMD","padOffset","isLE","super","pos","view","len","take","Math","set","subarray","process","dataView","roundClean","digestInto","fill","setBigUint64","_32n","BigInt","_u32_max","wh","wl","l","setUint32","oview","outLen","state","get","res","destroy","to","SHA256_K","SHA256_IV","SHA256_W","SHA256","A","B","C","D","E","F","G","H","offset","getUint32","W15","W2","s0","s1","T1","T2","sha256","webCrypto","globalThis","crypto","undefined","nodeRequire","module","require","bind","wrapHash","_sha256","concat","uint8arr","reduce","size","chunkList","cur","hashList"],"mappings":"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"}